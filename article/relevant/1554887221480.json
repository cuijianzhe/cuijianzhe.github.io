{"relevantArticles":[{"articleTitle":"并发工具类 ---Semaphore","articleAbstractText":"\u2003\u2003 \u2003\u2003 举例示意 \u2003\u2003北京开往邯郸的火车K7761开始售票，在9号站台验票进站，进站口只有三个，许许多多的乘客排成长队验票进站。  那么此时三个进站口就是有限的公共资源，乘客们就是线程。  Semaphore信号量是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。  package com.jianwei; import java.util.concurrent.Semaphore; public class 上传思路 { public static void main(String[] args) throws Exception{ SemaphoreService service = new SemaphoreService(); for (int i = 0; i &lt; 60; i++) { MyThread t = new MyThread(\"thread\" + (i + 1), service); t.start();// 这里使用 t.run() 也可以运行，但是不是并发执行了  } } }  package com.jianwei....","articleStatus":0,"articlePermalink":"/articles/2019/04/15/1555318114318.html","articleImg1URL":"https://img.hacpai.com/bing/20180701.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"多线程之倒计时计数器 CountDownLatch","articleAbstractText":"上篇回顾：多线程回环栅栏 CyclicBarrier 使用场景 假设有一个列表，多选之后，点击压缩。此时后台肯定是多线程跑压缩任务，那我们就可以使用CountDownLatch来在全部压缩完成之后处理一些事情。 示例代码 public class testMain { public static void main(String[] args) { // 初始化计数 AtomicInteger count = new AtomicInteger(0); // 创建 10 个线程 ExecutorService es = Executors.newFixedThreadPool(10); // 设置 CountDownLatch 为 10 CountDownLatch countDownLatch = new CountDownLatch(10); for (int i = 0; i &lt; 10; i++) { es.execute(() -&gt; { // 每个线程累计增加 1000 次 for (int j = 0; j &lt; 1000; j++) { count.addA....","articleStatus":0,"articlePermalink":"/articles/2019/04/15/1555309259187.html","articleImg1URL":"https://img.hacpai.com/bing/20171216.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}